# Copyright (c) 2020-2021 the Mondradiko contributors.
# SPDX-License-Identifier: LGPL-3.0-or-later

"""Tool for generating WebAssembly bindings for components from TOML files.
It currently only supports C++, but will eventually support other targets."""

import sys
from email.utils import formatdate
import toml

PREAMBLE_TEMPLATE = """
// Mondradiko scripting API - {summary}
// https://mondradiko.github.io/
// Generated by generate_binding.py on {timestamp}
"""[1:]

LINKER_METHOD_TEMPLATES = """
template <class ComponentType>
using BoundComponentMethod = wasm_trap_t* (ComponentType::*)(const wasm_val_t[], wasm_val_t[]);

template <class ComponentType, BoundComponentMethod<ComponentType> method>
static wasm_trap_t* componentMethodWrapper(const wasmtime_caller_t* caller, void* env, const wasm_val_t args[], wasm_val_t results[]) {
  World* world = reinterpret_cast<World*>(env);
  EntityId self_id = static_cast<EntityId>(args[0].of.i32);
  ComponentType& self = world->registry.get<ComponentType>(self_id);
  return (self.*method)(args, results);
}

static void finalizer(void*) { }

template <class ComponentType, BoundComponentMethod<ComponentType> method>
void linkComponentMethod(ScriptEnvironment* scripts, World* world, const char* symbol) {
  wasm_store_t* store = scripts->getStore();
  const wasm_functype_t* func_type = wasm_functype_new_0_0();
  wasmtime_func_callback_with_env_t callback =
    componentMethodWrapper<ComponentType, method>;
  void* env = static_cast<void*>(world);

  wasm_func_t* func =
    wasmtime_func_new_with_env(store, func_type, callback, env, finalizer);

  scripts->addBinding(symbol, func);
}

"""

LINKER_LINK_FORMAT = "void {0}Component::linkScriptApi(ScriptEnvironment* scripts, World* world)"

LINKER_METHOD_WRAP = "linkComponentMethod<{0}, &{0}::{1}>(scripts, world, \"{0}_{1}\");"


def preamble(summary):
    """Create a timestamped header describing the file."""
    return PREAMBLE_TEMPLATE.format(summary=summary, timestamp=formatdate())


def cpp_documentation(tag, contents, indentation_level=2, margin=80):
    """Create a Doxygen tag in a word-wrapped block comment."""
    indent = " " * indentation_level

    docs = ["", "/**"]

    # Format contents to avoid margin
    content_line_len = margin - indentation_level
    content_words = contents.split()

    content_header = " *"
    content_line = f"{content_header} @{tag}"

    for word in content_words:
        if len(content_line) + len(word) >= content_line_len:
            docs.append(content_line)
            content_line = content_header
        content_line += " " + word

    if content_line != content_header:
        docs.append(content_line)

    docs.append(" */\n")
    return f"\n{indent}".join(docs)


class Codegen:
    """Base class for generating files containing methods."""
    def __init__(self, output_file, component_name):
        self.output_file = output_file
        self.component_name = component_name
        self.methods = []
        self.out = []

    def add_method(self, method_name, method):
        """Register a given method."""
        raise NotImplementedError()

    def finish(self):
        """Finish generating code and write it to the output file."""
        raise NotImplementedError()

    def _finish(self):
        with open(self.output_file, "w") as out_file:
            out_file.write("\n".join(self.out))


class Linker(Codegen):
    """C++ code generator for linking Wasm bindings to a ScriptEnvironment."""
    def __init__(self, output_file, component_name):
        super().__init__(output_file, component_name)

        self.out.extend([
            preamble("linking implementation"),

            # Import the component we're linking
            f'#include "core/components/{component_name}Component.h"',
            "",

            # Import common headers
            '#include "core/world/World.h"',
            '#include "core/scripting/ScriptEnvironment.h"',
            '#include "lib/include/wasm_headers.h"',
            ""
            "namespace mondradiko {",
            "",

            # Common link methods
            LINKER_METHOD_TEMPLATES])

    def add_method(self, method_name, method):
        # TODO(marceline-cramer) C++ name wrangling would go here
        # TODO(marceline-cramer) Also parsing overrides and automatic type conversions
        component_name = f"{self.component_name}Component"
        self.methods.append(LINKER_METHOD_WRAP.format(
            component_name, method_name))

    def finish(self):
        # Implement Component::linkScriptApi()
        self.out.extend([
            LINKER_LINK_FORMAT.format(self.component_name),
            " {"])

        self.out.extend(f"  {method}" for method in self.methods)

        self.out.extend([
            # End of Component::linkScriptApi()
            "}",
            "",

            # End of namespace
            "} // namespace mondradiko"
            ""])

        # Close linker source file
        self._finish()


class CppBinding(Codegen):
    """C++ code generator for header files with bindings for Wasm modules."""
    def __init__(self, output_file, component_name):
        super().__init__(output_file, component_name)

        self.out.extend([
            preamble("C++ bindings"),
            "#pragma once",
            "",

            # Enter namespace
            "namespace mondradiko {\n",

            # Class body
            f"class {component_name} {{",

            # Public members
            " public:",
        ])

    def add_method(self, method_name, method):
        # Generate Doxygen-style tags
        self.out.append(cpp_documentation("brief", method["brief"]))

        # Define the method
        return_type = method.get("return", "void")
        parameters = method.get("params", [])
        parameter_list = ", ".join(parameters)
        self.out.append(f"  {return_type} {method_name}({parameter_list});\n")

    def finish(self):
        self._finish()


def main():
    """Generate a binding file and a linker file given a component TOML."""
    if len(sys.argv) != 4:
        print("Usage:")
        print(f" {sys.argv[0]} [in_component_definition.toml] [linker.cc] [cpp_binding.h]")
        sys.exit(1)

    component_path = sys.argv[1]
    linker_path = sys.argv[2]
    cpp_binding_path = sys.argv[3]

    component = toml.load(component_path)

    # Open the files we'll be writing to
    component_name = component["name"]
    linker = Linker(linker_path, component_name)
    cpp_binding = CppBinding(cpp_binding_path, component_name)

    # Define methods
    methods = component["methods"]
    for method_name, method in methods.items():
        linker.add_method(method_name, method)
        cpp_binding.add_method(method_name, method)

    # Wrap up codegen
    linker.finish()
    cpp_binding.finish()


if __name__ == "__main__":
    main()
